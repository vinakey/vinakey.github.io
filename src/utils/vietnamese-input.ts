/**
 * Vietnamese Input Manager
 *
 * Manages Vietnamese typing through various input methods.
 * Uses ANVIM engine (AVIM.js compatible) for all input methods.
 * Attaches to text inputs and transforms typing as user types.
 */
export type InputMethod = "OFF" | "AUTO" | "TELEX" | "VNI" | "VIQR";

import {
  AnvimEngine,
  type VietnameseInputMethod,
} from "@/engine/methods/anvim";
import { logger } from "@/utils/logger";

class VietnameseInput {
  private anvimEngine = new AnvimEngine();
  private attachedElements = new Set<HTMLElement>();
  private currentMethod: InputMethod = "OFF"; // Start with OFF
  private enabled: boolean = true;
  private currentWords = new Map<HTMLElement, string>(); // Track current word being typed
  private originalWords = new Map<HTMLElement, string>(); // Track original typed sequence
  private lastCursorPositions = new Map<HTMLElement, number>(); // Track cursor position

  constructor() {
    logger.info(
      "üöÄ Vietnamese ANVIM engine initialized - supporting AUTO/TELEX/VNI/VIQR methods!",
    );
    if (typeof window !== "undefined") {
      (window as any).anvimEngine = this.anvimEngine;
    }
  }

  public attach(element: HTMLTextAreaElement | HTMLInputElement): void {
    if (this.attachedElements.has(element)) return;

    this.attachedElements.add(element);
    this.currentWords.set(element, "");
    this.lastCursorPositions.set(element, 0);

    // Attach event listeners for Vietnamese input processing
    this.setupEventListeners(element);
    logger.debug("‚úì Vietnamese ANVIM engine attached to editor textarea!");
  }

  public detach(element: HTMLTextAreaElement | HTMLInputElement): void {
    if (!this.attachedElements.has(element)) return;

    this.attachedElements.delete(element);
    this.currentWords.delete(element);
    this.originalWords.delete(element);
    this.lastCursorPositions.delete(element);

    // Remove event listeners
    this.removeEventListeners(element);
    logger.debug("‚úì Vietnamese TELEX engine detached from element");
  }

  private setupEventListeners(element: HTMLElement): void {
    if (!(element as any)._vietnameseInputAttached) {
      // Use input event to process after the value is updated
      element.addEventListener(
        "input",
        this.handleInputWithProcessing.bind(this, element) as any,
      );
      element.addEventListener(
        "keydown",
        this.handleKeyDown.bind(this, element),
      );
      (element as any)._vietnameseInputAttached = true;
    }
  }

  private removeEventListeners(element: HTMLElement): void {
    // Clean up listeners
    (element as any)._vietnameseInputAttached = false;
  }

  private handleKeyDown(element: HTMLElement, event: KeyboardEvent): void {
    if (!this.enabled || this.currentMethod === "OFF") return;

    // Reset word tracking on space, enter, or word boundary characters
    if (event.key === " " || event.key === "Enter" || event.key === "Tab") {
      this.currentWords.set(element, "");
      this.originalWords.set(element, "");
    }
  }

  private handleInputWithProcessing(element: HTMLElement, event: Event): void {
    if (!this.enabled || this.currentMethod === "OFF") return;

    // Ignore events generated by our own processing
    if ((event as any)._vietnameseProcessed) return;

    this.processCurrentWord(element as HTMLInputElement | HTMLTextAreaElement);
  }

  private processCurrentWord(
    inputElement: HTMLInputElement | HTMLTextAreaElement,
  ): void {
    const cursorPos = inputElement.selectionStart || 0;
    const textBefore = inputElement.value.substring(0, cursorPos);
    const textAfter = inputElement.value.substring(cursorPos);

    if (textBefore.length === 0) return;

    // Treat the last typed character as the key (can be letter, digit, or punctuation)
    const lastKey = textBefore.slice(-1);
    const priorText = textBefore.slice(0, -1);

    // Extract the prefix word (letters with combining marks) immediately before the key
    // This allows VNI digits and VIQR punctuation to be handled as the key
    const prefixMatch = priorText.match(/[\p{L}\u0300-\u036f]+$/u);
    const prefix = prefixMatch ? prefixMatch[0] : "";

    if (prefix.length === 0 && /[\p{L}]/u.test(lastKey) === false) {
      // No word context and key isn't a letter ‚Üí nothing to process
      return;
    }

    this.anvimEngine.setMethodByString(
      this.currentMethod as VietnameseInputMethod,
    );
    const processedWord = this.anvimEngine
      .processWithKey(prefix.normalize("NFC"), lastKey)
      .normalize("NFC");

    const currentWord = prefix + lastKey;

    if (processedWord !== currentWord) {
      const beforeWord = priorText.substring(
        0,
        priorText.length - prefix.length,
      );
      const newValue = beforeWord + processedWord + textAfter;
      const newCursorPos = beforeWord.length + processedWord.length;

      inputElement.value = newValue;
      inputElement.setSelectionRange(newCursorPos, newCursorPos);

      const inputEvent = new Event("input", { bubbles: true });

      (inputEvent as any)._vietnameseProcessed = true;
      inputElement.dispatchEvent(inputEvent);
    }
  }

  public setMethod(method: InputMethod): void {
    const oldMethod = this.currentMethod;

    this.currentMethod = method;

    // Clear all current word states when switching methods
    this.currentWords.clear();
    this.originalWords.clear();
    this.lastCursorPositions.clear();

    logger.info(`üîÑ Input method changed: ${oldMethod} ‚Üí ${method}`);

    if (method === "OFF") {
      logger.info("‚ùå Vietnamese input disabled");
    } else {
      logger.info(`‚úÖ ${method} mode active - Vietnamese typing enabled!`);
    }
  }

  public setEnabled(enabled: boolean): void {
    this.enabled = enabled;

    // Clear all current word states when enabling/disabling
    this.currentWords.clear();
    this.originalWords.clear();
    this.lastCursorPositions.clear();

    logger.info(
      enabled ? "‚úÖ Vietnamese input enabled" : "‚ùå Vietnamese input disabled",
    );
  }

  public getMethod(): InputMethod {
    return this.currentMethod;
  }

  public isEnabled(): boolean {
    return this.enabled;
  }

  public getEngineInfo(): string {
    return "Vietnamese ANVIM Engine v3.0 - Supporting AUTO/TELEX/VNI/VIQR methods with AVIM.js compatibility";
  }
}

// Export singleton instance
export const vietnameseInput = new VietnameseInput();

// Make it available globally for console testing
if (typeof window !== "undefined") {
  (window as any).vietnameseInput = vietnameseInput;
  logger.info("üåê vietnameseInput is now available in console!");
}
